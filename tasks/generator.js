'use strict'

const Config = require('config');
let MongoClient = require('mongodb').MongoClient;
let vasync = require('vasync');
let _ = require('underscore');
let fs = require('fs');
let path = require('path');


module.exports = function generateCSS(onComplete) {
    console.info('Starting to generate css');

    MongoClient.connect(Config.getMongoDbURL(), function(dbError, db) {
        if (dbError) {
            console.error('Failed to connect to database', dbError);
            onComplete();
            return;
        }

        let barrier = vasync.barrier();
        barrier.on('drain', function() {
            console.info('Finished generating CSS');
            db.close();
            onComplete();
        });

        generateFiles(db, barrier);
    });
}

function generateFiles(db, barrier) {
    const types = ['all', 'anime', 'manga'];
    const selectors = ['self', 'before', 'after', 'more'];

    let cssToGenerate = (function crossProduct() {
        return _.reduce(arguments, function(a, b) {
            return _.flatten(_.map(a, function(x) {
                return _.map(b, function(y) {
                    return x.concat([y]);
                });
            }), true);
        }, [ [] ]);
    })(types, selectors);

    // +1 for db closing listener
    // +1 for closing cssFileStream
    barrier.setMaxListeners(cssToGenerate.length + 2);

    for (let css of cssToGenerate) {
        generate(db, barrier, css[0], css[1]);
    }
}

function generate(db, barrier, type, selector) {
    if (type === 'all' && selector === 'more') {
        // The '#more[mal id]' selector is based on MAL's id which is not unique for both manga and anime 
        // i.e. different manga/anime can share the same id
        return;
    }

    // Create the file stream
    const fileName = path.join(__dirname, '../public/generated/' + type + '-' + selector + '.css');
    let cssFileStream = fs.createWriteStream(fileName, { flags: 'w' });
    cssFileStream.write('/* This file was generated by https://www.malcovercss.link */\n\n');
    cssFileStream.on('error', function() {
        console.error('Failed to write file', fileName);
    });
    cssFileStream.on('finish', function() {
        console.info('Successfully wrote to file', fileName);
    });
    barrier.on('drain', function() {
        cssFileStream.end();
    });

    // Iterate over items in database
    const query = (type === 'all') ? {} : { type: type };
    let cursor = db.collection(Config.MAL_ITEMS_COLLECTION).find(query);
    cursor.forEach(function(item) {
        const barrierKey = 'generating mal item:' + type + ':' + selector + ':' + item._id;
        barrier.start(barrierKey);

        let cssRule = getCSSRule(item, selector);
        cssFileStream.write(cssRule, function() {
            barrier.done(barrierKey);
        });
    });
}

function getCSSRule(item, selector) {
    let cssRule = '';

    switch (selector) {
        case 'more':
            cssRule += '#more' + item.malId;
            break;

        case 'self':
            cssRule += '.animetitle';
            cssRule += '[href^="/' + item.type + '/' + item.malId + '/"]';
            break;

        case 'before':
        case 'after':
            cssRule += '.animetitle';
            cssRule += '[href^="/' + item.type + '/' + item.malId + '/"]:' + selector;
            break;
    }

    cssRule += '{background-image:url(' + item.imgUrl + ');}\n';
    return cssRule;
}
