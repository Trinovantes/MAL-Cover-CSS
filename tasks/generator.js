'use strict'

const Config = require('config');
const MongoClient = require('mongodb').MongoClient;

const vasync = require('vasync');
const _ = require('underscore');
const fs = require('fs');
const path = require('path');
const logger = require("winston-color");

//-----------------------------------------------------------------------------
// Generator
//-----------------------------------------------------------------------------

module.exports = function generateCSS(onComplete) {
    const types = ['all', 'anime', 'manga'];
    const selectors = ['self', 'before', 'after', 'more'];
    const cssToGenerate = (function crossProduct() {
        return _.reduce(arguments, function(a, b) {
            return _.flatten(_.map(a, function(x) {
                return _.map(b, function(y) {
                    return x.concat([y]);
                });
            }), true);
        }, [ [] ]);
    })(types, selectors);

    logger.info('Starting to generate css', cssToGenerate);
    MongoClient.connect(Config.getMongoDbURL(), function(dbError, db) {
        if (dbError) {
            logger.error('Failed to connect to database', dbError);
            onComplete();
            return;
        }

        let dbBarrier = vasync.barrier();
        dbBarrier.on('drain', function() {
            logger.info('Finished generating CSS');
            db.close();
            onComplete();
        });

        for (let css of cssToGenerate) {
            generate(db, dbBarrier, css[0], css[1]);
        }
    });
}

//-----------------------------------------------------------------------------
// Helpers
//-----------------------------------------------------------------------------

function generate(db, dbBarrier, type, selector) {
    if (type === 'all' && selector === 'more') {
        // The '#more[mal id]' selector is based on MAL's id which is not unique for both manga and anime
        // i.e. different manga/anime can share the same id
        return;
    }

    const fileName = path.join(__dirname, '../public/generated/' + type + '-' + selector + '.css');
    dbBarrier.start(fileName);

    // Create the file stream
    let cssFileStream = fs.createWriteStream(fileName, { flags: 'w' });
    cssFileStream.write('/* This file was generated by https://www.malcovercss.link */\n\n');
    cssFileStream.on('error', function(error) {
        logger.error("Failed to write file '%s'", fileName, error);
    });

    // Iterate over items in database
    const query = (type === 'all') ? {} : { type: type };
    let cssCursor = db.collection(Config.MAL_ITEMS_COLLECTION).find(query);
    let cssBarrier = vasync.barrier();
    cssCursor.forEach(function(malItem) {
        const barrierKey = 'generating mal item:' + type + ':' + selector + ':' + malItem._id;
        cssBarrier.start(barrierKey);

        let cssRule = getCSSRule(malItem, selector);
        cssFileStream.write(cssRule, function() {
            cssBarrier.done(barrierKey);
        });
    });

    // Clean up once all css has been written
    cssBarrier.on('drain', function() {
        if (cssCursor.isClosed()) {
            logger.info("Finished writing to '%s'", fileName);
            cssFileStream.end();
            dbBarrier.done(fileName);
        }
    });
}

function getCSSRule(item, selector) {
    let cssRule = '';

    switch (selector) {
        case 'more':
            cssRule += '#more' + item.malId;
            break;

        case 'self':
            cssRule += '.animetitle';
            cssRule += '[href^="/' + item.type + '/' + item.malId + '/"]';
            break;

        case 'before':
        case 'after':
            cssRule += '.animetitle';
            cssRule += '[href^="/' + item.type + '/' + item.malId + '/"]:' + selector;
            break;
    }

    cssRule += '{background-image:url(' + item.imgUrl + ');}\n';
    return cssRule;
}
